use std::io;

const N_X_MAX: usize = 150;
const N_Y_MAX: usize = 150;

const X_RANGE: (f64, f64) = (-6.0, 3.0);
const Y_RANGE: (f64, f64) = (-6.0, 3.0);


const MAX_ITERS: usize = 10000;

const FILL_CHAR: char  = '*';

const DEBUG: bool = false;

fn main() {

let result = (0..N_Y_MAX).into_iter()
                         .map(|y| (0..N_X_MAX).into_iter()
                                              .map( |x| (x,y))
                                              .map(|pt| discrete_to_float(pt))
                                              .map(|pt| test_point(pt))
                                              .map(|val| if(val){ FILL_CHAR} else {" "})
                                              .join(""))
                         .join("\n");

print!("{}", result);
}
                                              




fn discrete_to_float(lattice_point: (usize, usize)) -> (f64, f64){
	let x_val = discrete_to_float_single(lattice_point.0, N_X_MAX,  X_RANGE.0, X_RANGE.1);
	let y_val = discrete_to_float_single(lattice_point.1, N_Y_MAX, Y_RANGE.0, Y_RANGE.1); 

	return (x_val, y_val) ;

	fn discrete_to_float_single(val: usize, max: usize, lower_limit: f64, upper_limit: f64) -> f64{
		let ratio = (val as f64)/(max as f64);

		return  lower_limit + (upper_limit - lower_limit)*ratio ;
	}
}

fn test_point(param: (f64, f64)) -> bool{

	return param.0   <= param.1*param.1;

	return  param.0*param.0 + param.1*param.1 <= 1.0;

	let z: (f64, f64) = param; // starting at z=0 would produce this result. 


	for _n in 1..MAX_ITERS{
		let z = next_iter(z, param);

		if (z.0).powi(2) + (z.1).powi(2) >= 2.0*2.0 {
			return false ;
		}
	} 

	return true;

	fn next_iter(z: (f64, f64), param: (f64, f64)) -> (f64, f64){

		let new_real = (z.0)*(z.0) - (z.1)*(z.1) + param.0;
		let new_imag = 2.0*(z.0)*(z.1) + param.1;

		return (new_real, new_imag);

	}
}
